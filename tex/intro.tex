%# -*- coding: utf-8-unix -*-
%%==================================================
%% chapter01.tex for SJTU Master Thesis
%%==================================================

%\bibliographystyle{sjtu2}%[此处用于每章都生产参考文献]
\chapter{绪论}
\label{chap:intro}


\section{研究背景和意义}
近年来，NUMA架构的服务器逐渐普及，它的出现解决了对称多处理器（symmetric multiprocessor architecture，SMP）架构在可扩展性方面的局限性，所以已经成为现代服务器架构设计中的一种趋势和规范。对于大型内存数据库(例如Microsoft SQL server）和处理引擎（例如spark）等高并发的应用来说，可扩展性较好的NUMA架构使得它们可以进一步地扩展，生成更多的线程，并将这些线程分布到所有的NUMA就算核心上来尽可能地利用所以计算核心地计算资源。这些共享内存地多线程应用通常有很多在所有线程之间共享并且需要同步机制内保护地数据。尽管近年来事务内存（transaction memory）开始流行，但是对于这些高并发地应用来说，在高度竞争地情况下锁依然是一种最基本最重要地同步机制。

在传统地SMP架构中，基于队列地锁，例如CLH和MCS锁，一直是许多锁集中地高性能系统地不二之选。这些基于队列的锁被选择的主要原因是，他们将所有等待访问关键区域的线程排成先进先出的队列，每个线程在被分隔开的内存区域等待锁，从而减少了总的用于维持缓存一致性的数据流，提高了系统的总体性能。然后在NUMA架构中，这些基于队列的锁的性能显著下降，这主要是由NUMA架构机器的物理架构决定的。NUMA架构的机器通常由一组拥有快速本地内存的计算核心组成，这些计算核心之间通过较慢的芯片间通信介质来通信。在这种架构的机器中，某个计算核心访问本地内存，尤其是本地共享缓存的速度可以达到访问在其他计算核心上的内存或缓存的速度的数倍。由于传统的基于队列的锁不知道硬件层面的NUMA特性，为了保持先来先服务的锁传递顺序，就会产生锁在各个NUMA计算节点之间的随意传递，而锁在NUMA节点之间的传递时间通常会是在同一个NUMA节点内传递时间的数倍，所以相比SMP架构，性能会有显著下降。

NUMA架构的流行和传统基于队列的锁在其上的性能衰退促使研究者开始发展局部性感知的层级锁，例如cohort lock，HMCS lock， AHMCS lock等。层级锁的本质是通过牺牲锁的短期公平性（short-term fairness）来提高吞吐率，也就是说改变锁的传递顺序，使其尽可能多地在运行在同一个NUMA节点内部之间传递。具体来说，某个线程在放锁地时候偏向于将其传给一个“最近”地等待者而不是“最早”地等待者，从而减少锁及其保护地数据在NUMA节点之间传递地频率进而提高锁地吞吐率。另外，为了避免深层地不公平，层级锁通常会设定一个上限来限制其在单个NUMA节点中地连续最大传递次数。

从上述说明可以看出层级锁主要通过挖掘线程之间地局部性来提高性能，因此对于某个特定的层级锁来说，线程本身地放置和分布对其最终性能提升及其他特性必然有很重要地影响，选择合适地线程放置策略对于层级锁地性能非常关键。

由于层级锁偏向于寻找最近地等待者完成锁传递，因此最自然地线程放置策略是将线程尽可能地放得紧凑（compact），这也是目前大多数层级锁中的默认线程放置策略。具体来说，新的线程会尽可能地被放置在当前NUMA节点地某个可用计算核心上，只有当前地NUMA节点上没有可用地计算核心时，新的线程才会被放置到一个新NUMA节点地某个专用计算核心上。相比操作系统默认地线程调度策略，紧凑策略更好地控制了CPU资源地分配，保存了更多地局部性，因此使得层级锁能够获得尽可能高地性能。但是，紧凑策略通常会带来不能保证层级锁地长期公平性（long-term fairness），具体来说，线程之间地拿锁次数有很大差异。对于公有云等应用场景来说，长期公平性地缺失会是一个很大地问题。

另一种主要的线程放置策略是平均放置（even），也就是说线程被平均地放置在所有的NUMA节点上。由于每个节点上运行相同数量的线程，所以每个节点具有相同的将锁保持在其上的能力，因此平均放置地策略能够很好地保证层级锁地长期公平性。但是在锁地竞争不足时相比紧凑策略会有很大地吞吐率损失。这主要是因为平均放置使得线程分布更为分散，而相同的竞争能力又使得锁很容易在NUMA节点之间随意传递，所以在竞争不足时层级锁不能有效地挖掘同一个NUMA节点上地线程之间地局部性。吞吐率地损失有悖于层级锁的研究初衷，对于主要应用于高性能系统层级锁而言严重地吞吐率损失显然时难以接受的。

从以上背景可以看出，研究现有线程放置策略或者不能同时兼顾层级锁对高性能和长期公平性地需求，或者不能适应所有应用中锁竞争强度地变化。但是同时保证这两个特性，并且适应锁竞争地变化又是一般应用场景必备的，所以本文的研究基于上述问题，利用层级锁中现有线程放置策略的优势，解决其不能适应竞争强度地变化和不能兼顾吞吐率和长期公平性的缺陷，使得层级锁在任何竞争状况下都能同时保证高吞吐率和长期公平性。从而能够在适应NUMA架构的同时，更好改善多线程共享内存应用的性能，并且保证线程之间的长期公平性。

NUMA架构的出现解决了硬件层面的扩展性问题，层级锁的出现改善了传统锁（软件层面）的扩展性问题，而本文的研究的主要意义在于使得层级锁在保持性能和可扩展性的前提下保证长期公平性。考虑到NUMA架构的机器的不断普及和公有云等对公平性，性能和可扩展性都有很高要求的应用场景的不断增多，本文的研究在未来将会有更大应用前景。
\section{国内外研究现状}
\section{研究内容和结构安排}
\section{本章小结}

\subsection{准备工作}
\label{sec:requirements}

要使用这个模板撰写学位论文，需要在\emph{TeX系统}、\emph{TeX技能}上有所准备。

\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
	\item {\TeX}系统：所使用的{\TeX}系统要支持 \XeTeX 引擎，且带有ctex 2.x宏包，以2015年的\emph{完整}TeXLive、MacTeX发行版为佳。
	\item TeX技能：尽管提供了对模板的必要说明，但这不是一份“ \LaTeX 入门文档”。在使用前请先通读其他入门文档。
	\item 针对Windows用户的额外需求：学位论文模本分别使用git和GNUMake进行版本控制和构建，建议从Cygwin\footnote{\url{http://cygwin.com}}安装这两个工具。
\end{itemize}

\subsection{模板选项}
\label{sec:thesisoption}

sjtuthesis提供了一些常用选项，在thesis.tex在导入sjtuthesis模板类时，可以组合使用。
这些选项包括：

\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
	\item 学位类型：bachelor(学位)、master(硕士)、doctor(博士)，是必选项。
	\item 中文字体：fandol(Fandol 开源字体)、windows(Windows 系统下的中文字体)、mac(macOS 系统下的华文字体)、ubuntu(Ubuntu 系统下的文泉驿和文鼎字体)、adobe(Adobe 公司的中文字体)、founder(方正公司的中文字体)，默认根据操作系统自动配置。
	\item 英文模版：使用english选项启用英文模版。
	\item 盲审选项：使用review选项后，论文作者、学号、导师姓名、致谢、发表论文和参与项目将被隐去。
\end{itemize}

\subsection{编译模板}
\label{sec:process}

模板默认使用GNUMake构建，GNUMake将调用latemk工具自动完成模板多轮编译：

\begin{lstlisting}[basicstyle=\small\ttfamily, caption={编译模板}, numbers=none]
make clean thesis.pdf
\end{lstlisting}

若需要生成包含“原创性声明扫描件”的学位论文文档，请将扫描件保存为statement.pdf，然后调用make生成submit.pdf。

\begin{lstlisting}[basicstyle=\small\ttfamily, caption={生成用于提交的学位论文}, numbers=none]
make clean submit.pdf
\end{lstlisting}

编译失败时，可以尝试手动逐次编译，定位故障。

\begin{lstlisting}[basicstyle=\small\ttfamily, caption={手动逐次编译}, numbers=none]
xelatex -no-pdf thesis
biber --debug thesis
xelatex thesis
xelatex thesis
\end{lstlisting}

\subsection{模板文件布局}
\label{sec:layout}

\begin{lstlisting}[basicstyle=\small\ttfamily,caption={模板文件布局},label=layout,float,numbers=none]
├── LICENSE
├── Makefile
├── README.md
├── bib
│   ├── chap1.bib
│   └── chap2.bib
├── bst
│   └── GBT7714-2005NLang.bst
├── figure
│   ├── chap2
│   │   ├── sjtulogo.eps
│   │   ├── sjtulogo.jpg
│   │   ├── sjtulogo.pdf
│   │   └── sjtulogo.png
│   └── sjtubanner.png
├── sjtuthesis.cfg
├── sjtuthesis.cls
├── statement.pdf
├── submit.pdf
├── tex
│   ├── abstract.tex
│   ├── ack.tex
│   ├── app_cjk.tex
│   ├── app_eq.tex
│   ├── app_log.tex
│   ├── chapter01.tex
│   ├── chapter02.tex
│   ├── chapter03.tex
│   ├── conclusion.tex
│   ├── id.tex
│   ├── patents.tex
│   ├── projects.tex
│   ├── pub.tex
│   └── symbol.tex
└── thesis.tex
\end{lstlisting}

本节介绍学位论文模板中木要文件和目录的功能。

\subsubsection{格式控制文件}
\label{sec:format}

格式控制文件控制着论文的表现形式，包括以下几个文件：
sjtuthesis.cfg, sjtuthesis.cls和GBT7714-2005NLang.bst。
其中，“cfg”和“cls”控制论文主体格式，“bst”控制参考文献条目的格式，

\subsubsection{主控文件thesis.tex}
\label{sec:thesistex}

主控文件thesis.tex的作用就是将你分散在多个文件中的内容“整合”成一篇完整的论文。
使用这个模板撰写学位论文时，你的学位论文内容和素材会被“拆散”到各个文件中：
譬如各章正文、各个附录、各章参考文献等等。
在thesis.tex中通过“include”命令将论文的各个部分包含进来，从而形成一篇结构完成的论文。
对模板定制时引入的宏包，建议放在导言区。

\subsubsection{各章源文件tex}
\label{sec:thesisbody}

这一部分是论文的主体，是以“章”为单位划分的，包括：

\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
	\item 中英文摘要(abstract.tex)。前言(frontmatter)的其他部分，中英文封面、原创性声明、授权信息在sjtuthesis.cls中定义，不单独分离为tex文件。
不单独弄成文件。
	\item 正文(mainmatter)——学位论文正文的各章内容，源文件是chapter\emph{xxx}.tex。
	\item 附录(app\emph{xx}.tex)、致谢(thuanks.tex)、攻读学位论文期间发表的学术论文目录(pub.tex)、个人简历(resume.tex)组成正文后的部分(backmatter)。
参考文献列表由bibtex插入，不作为一个单独的文件。
\end{itemize}

\subsubsection{图片文件夹figure}
\label{sec:fig}

figure文件夹放置了需要插入文档中的图片文件(支持PNG/JPG/PDF/EPS格式的图片)，可以在按照章节划分子目录。
模板文件中使用\verb|\graphicspath|命令定义了图片存储的顶层目录，在插入图片时，顶层目录名“figure”可省略。

\subsubsection{参考文献数据库bib}
\label{sec:bib}

目前参考文件数据库目录只存放一个参考文件数据库thesis.bib。
关于参考文献引用，可参考第\ref{chap:example}章中的例子。

